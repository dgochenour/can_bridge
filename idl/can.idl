// (c) Copyright, Real-Time Innovations, 2020.  All rights reserved.
// RTI grants Licensee a license to use, modify, compile, and create derivative
// works of the software solely for use with RTI Connext DDS. Licensee may
// redistribute copies of the software provided that all such copies are subject
// to this license. The software is provided "as is", with no warranty of any
// type, including any warranty for fitness for any purpose. RTI is under no
// obligation to maintain or support the software. RTI shall not be liable for
// any incidental or consequential damages arising out of the use or inability
// to use the software.


// From the Linux kernel in include/linux/can.h

// /**
//  * struct can_frame - basic CAN frame structure
//  * @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
//  * @can_dlc: frame payload length in byte (0 .. 8) aka data length code
//  *           N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1
//  *           mapping of the 'data length code' to the real payload length
//  * @__pad:   padding
//  * @__res0:  reserved / padding
//  * @__res1:  reserved / padding
//  * @data:    CAN frame payload (up to 8 byte)
//  */
// struct can_frame {
//     canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
//     __u8    can_dlc; /* frame payload length in byte (0 .. 8) */
//     __u8    __pad;   /* padding */
//     __u8    __res0;  /* reserved / padding */
//     __u8    __res1;  /* reserved / padding */
//     __u8    data[8] __attribute__((aligned(8)));
// };

// /*
// * defined bits for canfd_frame.flags
// *
// * The use of struct canfd_frame implies the Extended Data Length (EDL) bit to
// * be set in the CAN frame bitstream on the wire. The EDL bit switch turns
// * the CAN controllers bitstream processor into the CAN FD mode which creates
// * two new options within the CAN FD frame specification:
// *
// * Bit Rate Switch - to indicate a second bitrate is/was used for the payload
// * Error State Indicator - represents the error state of the transmitting node
// *
// * As the CANFD_ESI bit is internally generated by the transmitting CAN
// * controller only the CANFD_BRS bit is relevant for real CAN controllers when
// * building a CAN FD frame for transmission. Setting the CANFD_ESI bit can make
// * sense for virtual CAN interfaces to test applications with echoed frames.
// */
//
//
///**
// * struct canfd_frame - CAN flexible data rate frame structure
// * @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
// * @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)
// * @flags:  additional flags for CAN FD
// * @__res0: reserved / padding
// * @__res1: reserved / padding
// * @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)
// */
//struct canfd_frame {
//	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
//	__u8    len;     /* frame payload length in byte */
//	__u8    flags;   /* additional flags for CAN FD */
//	__u8    __res0;  /* reserved / padding */
//	__u8    __res1;  /* reserved / padding */
//	__u8    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));
//};

module rti {
    module vehicle {
        const string can_topic_name = "can_topic";

        // CAN FD payload length and DLC definitions according to ISO 11898-7
        const octet CANFD_MAX_DLC = 15;
        const octet CANFD_MAX_DLEN = 64;
        typedef unsigned long canid_t;

        struct can_frame {
            canid_t can_id;     // 32 bit CAN_ID + EFF/RTR/ERR flags
            octet can_dlc;      // frame payload length in byte (0 .. 8)
            octet data[8];      // data payload
        };

        struct canfd_frame {
            canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
            octet    len;     /* frame payload length in byte */
            octet    flags;   /* additional flags for CAN FD */
            octet    __res0;  /* reserved / padding */
            octet    __res1;  /* reserved / padding */
            octet    data[CANFD_MAX_DLEN];
        };

    };
};